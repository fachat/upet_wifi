
; The SPI-UART bridge is compatible with the standard UART,
; but is accessed via an SPI interface.
; As we use a dual UART, to channels are available.
;
; The first byte of a UART access contains:
;	b7: R/-W
;	b6: A3 (register select)
;	b5: A2
;	b4: A1
;	b3: A0
;	b2: CH1
;	b1: CH0
;	b0: -
;
; A0-3 are register selects. 
; 
; This is the register map:

UART_DATA	=0	; send (THR) / receive (RHR) data reg
UART_IER	=1	; interrupt enable reg
UART_IIR	=2	; interrupt identification (Read only)
UART_FCR	=2	; FIFO ctrl (Write only)
UART_LCR	=3	; Line Control Reg
UART_MCR	=4	; Modem Control Reg
UART_LSR	=5	; Line Status Reg
UART_MSR	=6	; Modem Status Reg
UART_SCR	=7	; Scratchpad

UART_TXLVL	=8	; Transmit FIFO level
UART_RXLVL	=9	; Receive FIFO level
UART_IODIR	=10	; I/O direction
UART_IOSTATE	=11	; I/O state
UART_IOINTEN	=12	; I/O interrupt enable
UART_IOCTRL	=14	; I/O control
UART_EFCR	=15	; extra features control reg

; special function register - accessible if LCR.7=1 and LCR != 0xbf
UART_DLL	=0	; Divisor Latch low
UART_DLH	=1	; Divisor Latch high

; enhanced registers - accessible if LCR = 0xbf
UART_EFR	=2	; Enhanced Function Reg 
UART_XON1	=4
UART_XON2	=5
UART_XOFF1	=6
UART_XOFF2	=7

; Accessible only if EFR.4=1 and MCR.2=1
UART_TCR	=6	; Transmission Control Reg
UART_TLR	=7	; Trigger Level Reg

; CH0/1 select the channel of the Dual UART
; 	CH[1:0]=00 	-> channel 0
;	CH[1:0]=01	-> channel 1
;
; The following access is either writing to a register (R/-W = 0)
; or reading the value from the register (R/-W = 1)
;
;
; clock multiplier
XTALMULT	=1

	.(

&uart_init .(
	lda #0
	sta chan

	; analog copy of UART init in GeckOS ser_uart.a65
	ldx #UART_MCR
	jsr uart_rd
	tay
inc $8000
	ldx #UART_MCR
	lda #$10		; enable loopback
	jsr uart_wr
inc $8000

	ldx #UART_MSR
	jsr uart_rd
	and #$30
	bne nodev_x
inc $8000
	
	ldx #UART_MCR
	lda #$1f
	jsr uart_wr
inc $8000

	ldx #UART_MSR
	jsr uart_rd
inc $8000
	
	and #$f0
	cmp #$f0
nodev_x	bne nodev

	ldx #UART_MCR
	tya
	jsr uart_wr

	ldx #UART_SCR
	lda #%10101010
	jsr uart_wr
	ldx #UART_SCR
	jsr uart_rd
	cmp #%10101010
	bne dev8250
	lsr
	ldx #UART_SCR
	jsr uart_wr
	ldx #UART_SCR
	jsr uart_rd
	cmp #%01010101
	bne dev8250

	ldx #UART_FCR
	lda #1
	jsr uart_wr

	ldx #UART_IIR
	jsr uart_rd
	tay

	ldx #UART_FCR
	lda #0
	jsr uart_wr

	tya
	asl
	bcc dev16450
	asl
	bcc dev16550

	ldx #UART_LCR
	lda #%1000000
	jsr uart_wr

	ldx #UART_DLL
	ldy #14*2		; 9600 baud
	lda divisor,y
	jsr uart_wr
	ldx #UART_DLH
	lda divisor+1,y
	jsr uart_wr

	ldx #UART_LCR
	lda #%00000011
	jsr uart_wr

	ldx #UART_FCR
	lda #7			; no FIFO enable and clear FIFOs, trigger lvl=1
	jsr uart_wr

	ldx #UART_IER
	lda #0			; disable ints (for now)
	jsr uart_wr

	ldx UART_MCR
	jsr uart_rd
	and #%00001100
	ldx #UART_MCR
	jsr uart_wr

	clc
	rts

nodev	ldx #0
	.byt $2c
dev8250	ldx #1
	.byt $2c
dev16450
	ldx #2
	.byt $2c
dev16550
	ldx #3
	sec
	rts
	.)

	; In: XR=reg number, chan=channel, A=data
&uart_wr .(
	pha
	lda chan
	lsr
	php
	txa
	jsr spisel
	asl		; CH1
	plp
	rol		; CH0
	asl		; unused bit
	jsr spitx
	pla
	jsr spitx
	jmp spidesel
	.)

	; In: XR=reg number, chan=channel
	; Out: A=value
&uart_rd .(
	lda chan
	lsr
	php
	txa
inc $8001
	jsr spisel
	asl		; CH1
	plp
	rol		; CH0
	asl		; unused bit
	ora #$80	; read
inc $8001
	jsr spitx
inc $8001
	jsr spirx
inc $8001
	jmp spidesel	; only uses X
	.)

/* 
 * 16550 divisor values for BAUD rates ?, 50, 75, 110, 134.5, 150, 
 * 300, 600, 1200, 1800, 2400, 3600, 4800, 7200, 9600, 19200
 */
divisor .word   -1, 2304 * XTALMULT, 1536 * XTALMULT, 1047 * XTALMULT
        .word   857 * XTALMULT, 768 * XTALMULT, 384 * XTALMULT
        .word   192 * XTALMULT, 96 * XTALMULT
        .word   64 * XTALMULT, 48 * XTALMULT, 32 * XTALMULT
        .word   24 * XTALMULT, 16 * XTALMULT, 12 * XTALMULT
        .word   6 * XTALMULT

chan	.byt 0
	.)
