
; The SPI-UART bridge is compatible with the standard UART,
; but is accessed via an SPI interface.
; As we use a dual UART, to channels are available.
;
; The first byte of a UART access contains:
;	b7: R/-W
;	b6: A3 (register select)
;	b5: A2
;	b4: A1
;	b3: A0
;	b2: CH1
;	b1: CH0
;	b0: -
;
; A0-3 are register selects. 
; 
; This is the register map:

	.(

UART_DATA	=0	; send (THR) / receive (RHR) data reg
UART_IER	=1	; interrupt enable reg
UART_IIR	=2	; interrupt identification (Read only)
UART_FCR	=2	; FIFO ctrl (Write only)
UART_LCR	=3	; Line Control Reg
UART_MCR	=4	; Modem Control Reg
UART_LSR	=5	; Line Status Reg
UART_MSR	=6	; Modem Status Reg
UART_SCR	=7	; Scratchpad

UART_TXLVL	=8	; Transmit FIFO level
UART_RXLVL	=9	; Receive FIFO level
UART_IODIR	=10	; I/O direction
UART_IOSTATE	=11	; I/O state
UART_IOINTEN	=12	; I/O interrupt enable
UART_IOCTRL	=14	; I/O control
UART_EFCR	=15	; extra features control reg

; special function register - accessible if LCR.7=1 and LCR != 0xbf
UART_DLL	=0	; Divisor Latch low
UART_DLH	=1	; Divisor Latch high

; enhanced registers - accessible if LCR = 0xbf
UART_EFR	=2	; Enhanced Function Reg 
UART_XON1	=4
UART_XON2	=5
UART_XOFF1	=6
UART_XOFF2	=7

; Accessible only if EFR.4=1 and MCR.2=1
UART_TCR	=6	; Transmission Control Reg
UART_TLR	=7	; Trigger Level Reg

; CH0/1 select the channel of the Dual UART
; 	CH[1:0]=00 	-> channel 0
;	CH[1:0]=01	-> channel 1
;
; The following access is either writing to a register (R/-W = 0)
; or reading the value from the register (R/-W = 1)
;
;
; clock multiplier
XTALMULT	=1


;-----------------------------------------------------------------

prep_cmd .(
	lda chan
	lsr
	php		; channel into carry
inc $8002
	jsr spisel	; uses XR only
	lda #UART_DATA
	asl		; CH1
	plp
	rol		; CH0
	asl		; unused bit
	rts
	.)

&spiuart_handle .(
	ldx #UART_LSR
	jsr uart_rd
	tay
	bmi rxerr

inc $8003
	ldx #UART_RXLVL
	jsr uart_rd
	tay		; number of bytes in rx FIFO
	beq dotx
	sta cnt

	; read buffer
	jsr prep_cmd
	ora #$80	; read
	jsr spitx

rxloop	jsr spirx

        ldy u0_rx_wp
        sta u0_rx_buf,y
        iny
        cpy u0_rx_rp
        beq rxoverflow
        sty u0_rx_wp

	dec cnt
	bne rxloop

	jsr spidesel	; only uses X
	bra dotx

rxerr	sta err
	ldx #UART_DATA
	jsr uart_rd	; clr error by reading byte
	bra dotx

rxoverflow
	rol err		; c is one due to compare equal

dotx	; check send
	; TODO: check TXLVL instead
inc $8006
	ldx #UART_LSR
	jsr uart_rd
	and #%00100000	; check THR empty
	beq notx

	; write buffer
	jsr prep_cmd
	jsr spitx

inc $8007
        ldx #64
	stx cnt
        ldy u0_tx_rp
txloop  cpy u0_tx_wp
        beq endtx
        lda u0_tx_buf,y
	jsr spitx
        iny
        dec cnt
        bne txloop      ; up to 64 bytes into FIFO
endtx   sty u0_tx_rp

	jsr spidesel
notx
	clc
	rts

	
inc $8005
	sec
	rts
	.)

	; set the channel for any following spiuart_* call
&spiuart_setchan .(
	and #1
	sta chan
	rts
	.)

&spiuart1_init 
	lda #1
	.byt $2c
&spiuart0_init .(
	lda #0		; AT command channel of ESP-C3-WROOM-02
	sta chan

	; analog copy of UART init in GeckOS ser_uart.a65
	ldx #UART_MCR
	jsr uart_rd
	tay
inc $8000
	ldx #UART_MCR
	lda #$10		; enable loopback
	jsr uart_wr
inc $8000

	ldx #UART_MSR
	jsr uart_rd
	and #$30
	bne nodev_x
inc $8000
	
	ldx #UART_MCR
	lda #$1f
	jsr uart_wr
inc $8000

	ldx #UART_MSR
	jsr uart_rd
inc $8000
	
	and #$f0
	cmp #$f0
nodev_x	beq :+
	jmp nodev
:
	ldx #UART_MCR
	tya
	jsr uart_wr

	ldx #UART_SCR
	lda #%10101010
	jsr uart_wr
	ldx #UART_SCR
	jsr uart_rd
	cmp #%10101010
	bne dev8250
	lsr
	ldx #UART_SCR
	jsr uart_wr
	ldx #UART_SCR
	jsr uart_rd
	cmp #%01010101
	bne dev8250

	ldx #UART_FCR
	lda #1		; enable FIFO
	jsr uart_wr

	ldx #UART_IIR
	jsr uart_rd
	tay

	ldx #UART_FCR
	lda #0
	jsr uart_wr

	tya
	asl
	bcc dev16450
	asl
	bcc dev16550

	ldx #UART_LCR
	lda #%10000000
	jsr uart_wr

	ldx #UART_DLL
	ldy #18*2		; 115200 baud
	lda divisor,y
sta $8008
	jsr uart_wr
	ldx #UART_DLH
	lda divisor+1,y
sta $8009
	jsr uart_wr

	ldx #UART_LCR
	lda #%00000011		; 8N1
	jsr uart_wr

	ldx #UART_IER
	lda #0			; disable ints (for now)
	jsr uart_wr

	ldx UART_MCR
	jsr uart_rd
	and #%00001100
	ldx #UART_MCR
	jsr uart_wr
	clc
	rts

nodev	ldx #0
	.byt $2c
dev8250	ldx #1
	.byt $2c
dev16450
	ldx #2
	.byt $2c
dev16550
	ldx #3
	sec
	rts
	.)

&spiuart_start .(
	; switch receiver on
	ldx #UART_MCR
	jsr uart_rd
	ora #%00000011		; activate DTR, RTS
	ldx #UART_MCR
	jsr uart_wr

	; send AT
	ldx #UART_DATA
	lda #"A"
	jsr uart_wr
	ldx #UART_DATA
	lda #"T"
	jsr uart_wr
	ldx #UART_DATA
	lda #13
	jsr uart_wr
	ldx #UART_DATA
	lda #10
	jsr uart_wr
	clc
	rts

	.)

	; In: XR=reg number, chan=channel, A=data
uart_wr .(
	sei
	pha
	lda chan
	lsr
	php
	txa
	jsr spisel
	asl		; CH1
	plp
	rol		; CH0
	asl		; unused bit
	jsr spitx
	pla
	jsr spitx
	jsr spidesel
	cli
	rts
	.)

	; In: XR=reg number, chan=channel
	; Out: A=value
uart_rd .(
	sei
	lda chan
	lsr
	php
	txa
inc $8001
	jsr spisel
	asl		; CH1
	plp
	rol		; CH0
	asl		; unused bit
	ora #$80	; read
inc $8001
	jsr spitx
inc $8001
	jsr spirx
inc $8001
	jsr spidesel	; only uses X
	cli
	rts
	.)

/* 
 * 16550 divisor values for BAUD rates ?, 50, 75, 110, 134.5, 150, 
 * 300, 600, 1200, 1800, 2400, 3600, 4800, 7200, 9600, 19200
 * 38400, 56000, 115200
 */
divisor .word   -1, 2304 * XTALMULT, 1536 * XTALMULT, 1047 * XTALMULT
        .word   857 * XTALMULT, 768 * XTALMULT, 384 * XTALMULT
        .word   192 * XTALMULT, 96 * XTALMULT
        .word   64 * XTALMULT, 48 * XTALMULT, 32 * XTALMULT
        .word   24 * XTALMULT, 16 * XTALMULT, 12 * XTALMULT
        .word   6 * XTALMULT
	.word 	3 * XTALMULT, 2 * XTALMULT, 1 * XTALMULT

chan	.byt 0
cnt	.byt 0
err	.byt 0

	.)
