
;
; This little program short-cuts between the serial0 port
; - i.e. the one with the real RS232 drivers and DB9 connector -A
; and the programming port of the ESP-C3-WROOM on the wifi module.
;
; I.e. it transfers all data from the WROOM to the serial0 and
; vice versa. This way the programming port of the WROOM
; becomes virtually available on the serial0 port of the UltiPET.
;
; Unfortunately this does not (yet) work with the Micro-PET.
; The Ultra-CPU board requires the UART+SIEC board for this.
;

#include "petdefs.i65"

#if 0
#define	ser_init	ser1_init
#define	ser_start	ser1_start
#define	ser_handle	ser1_handle
#define	uart		UART2
#else
#define	ser_init	ser0_init
#define	ser_start	ser0_start
#define	ser_handle	ser0_handle
#define	uart		UART
#endif

	.(
	.word START
	*=START
	.word link
	.word 10
	.byt $9e, "1040", 0	; SYS line
link	.word 0
	.dsb 1040-*
	.)

	lda #2		; 2 MHz CPU operation
	sta $e803

	; init serial0 uart
	jsr ser_init
	bcs exit
	jsr ser_start

	; init SPI uart0
	jsr spiuart0_init
	bcs exit
	jsr spiuart_start

	sei

#if 0
:	jsr ser_handle
	jsr spiuart_handle
	bra :-
#else
	bra rxtxloop

#endif
exit	sec
	brk


#include "upetspi.a65"

	.(

UART		=$e818
UART2		=$e828
	
UART_DATA       =0      ; send (THR) / receive (RHR) data reg
UART_IER        =1      ; interrupt enable reg
UART_IIR        =2      ; interrupt identification (Read only)
UART_FCR        =2      ; FIFO ctrl (Write only)
UART_LCR        =3      ; Line Control Reg
UART_MCR        =4      ; Modem Control Reg
UART_LSR        =5      ; Line Status Reg
UART_MSR        =6      ; Modem Status Reg
UART_SCR        =7      ; Scratchpad

UART_TXLVL      =8      ; Transmit FIFO level
UART_RXLVL      =9      ; Receive FIFO level

	;-----------------------------------------------------------------
	; direct copy wifi -> serial uart
&rxtxloop
	.(
next    ;ldx #UART_LSR<<3
        ;jsr uart_rd
        ;tay
        ;bpl toser

	;; clear error on rx
        ;ldx #UART_DATA<<3
        ;jsr uart_rd     ; clr error by reading byte
        ;bra next
toser
        ldx #UART_RXLVL<<3
        jsr uart_rd
sta $8027
inc $8026
        tay             ; number of bytes in rx FIFO
        beq towifi
        sta cnt

	SPISEL()

        ; read buffer
        lda rcmd
        ora #UART_DATA<<3
	SPITX1ST()
	SPIRXINIT()

rxloop  dec cnt
	beq last

	SPIRX()
	bra store

last	SPIRXLAST()

store	; directly store in tx fifo for output
	sta uart+UART_DATA

        lda cnt
        bne rxloop

        jsr spidesel    ; only uses X
	.)
towifi
	;-----------------------------------------------------------------
	; direct copy serial -> wifi uart
	.(
	lda uart+UART_LSR
	lsr
	bcc rxtxloop

	SPISEL()
	lda #UART_DATA<<3
	ora wcmd
	SPITX1ST()

rxloop  lda uart+UART_LSR
        bpl dotx
        lda uart+UART_DATA      ; advance fifo rd ptr to clear rx err
	bra rxloop
dotx
        lsr
        bcc endrx

        lda uart+UART_DATA

	SPITX()

        bra rxloop

endrx	SPIDESEL()
	.)

	jmp rxtxloop


	.)
	;-----------------------------------------------------------------


	; transfer buffers and pointers
	;
	; note, that they need to be 256 bytes long each

towifi_rp
	.byt 0
towifi_wp
	.byt 0

towifibuf	=$8100
	;.dsb 256

fromwifi_rp
	.byt 0
fromwifi_wp
	.byt 0

fromwifibuf	=$8200
	;.dsb 256

; definitions for the serial 0
s0_tx_buf = fromwifibuf
s0_tx_wp  = fromwifi_wp
s0_tx_rp  = fromwifi_rp

s0_rx_buf = towifibuf
s0_rx_wp  = towifi_wp
s0_rx_rp  = towifi_rp

; definitions for the serial 1 - same as for 0, for testing only
s1_tx_buf = fromwifibuf
s1_tx_wp  = fromwifi_wp
s1_tx_rp  = fromwifi_rp

s1_rx_buf = towifibuf
s1_rx_wp  = towifi_wp
s1_rx_rp  = towifi_rp


; definition for spi uart
u0_tx_buf = towifibuf
u0_tx_wp  = towifi_wp
u0_tx_rp  = towifi_rp

u0_rx_buf = fromwifibuf
u0_rx_wp  = fromwifi_wp
u0_rx_rp  = fromwifi_rp




;#define	S0_ONLY
#include "seruart.a65"

#include "spiuart.a65"

